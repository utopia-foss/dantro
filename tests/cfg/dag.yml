# Configurations for the TransformationsDAG life cycle test
---
# Selecting items -------------------------------------------------------------
empty:
  params: {}
  expected:
    num_nodes: 0
    num_objects: 2
    tags: [dag, dm, select_base]
    results: {}


explicit_select:
  params:
    transform:
      - operation: getitem
        args:
          - !dag_tag dm
          - some/path
      - operation: getitem
        args:
          - !dag_node -1
          - foo
        tag: foo

      - operation: getitem
        args:
          - !dag_tag dm
          - some/path/bar
        tag: bar

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, foo, bar]
    node_hashes:
      - &hash_getitem_some_path 275d726a23c0c8d1becb5a4798f25336
      - &hash_getitem_foo 39175b65f33504b4482667416f144a42
      - &hash_getitem_some_path_bar eeab72a23ead10056436b6bb025d328a
    node_dependencies:
      - - &hash_dm 38518b2446b95e8834372949a8e9dfc2  # 0 -> DataManager
      - - *hash_getitem_some_path                    # 1 -> 0
      - - *hash_dm                                   # 2 -> DataManager
    cache_dir_available: false
    results: &results_explicit_select
      foo:
        type: OrderedDataGroup
        attributes:
          path: /TestDM/some/path/foo
          name: foo
        find_tag: true
      bar:
        type: OrderedDataGroup
        attributes:
          path: /TestDM/some/path/bar
          name: bar
        find_tag: true


shorthand_select:
  params:
    select:
      foo: some/path/foo
      bar:
        path: some/path/bar
        transform: []

  expected:
    num_nodes: 2
    num_objects: 4
    tags: [dag, dm, select_base, foo, bar]
    cache_dir_available: false
    node_hashes:
      - *hash_getitem_some_path_bar  # comes first b/c select orders by keys
      - &hash_getitem_some_path_foo ade7a2a874aa2cab4b1c02f9ab28a6d7
    node_dependencies:
      - - *hash_dm
      - - *hash_dm
    results:
      <<: *results_explicit_select


# Define interface ------------------------------------------------------------

define_simple:
  params:
    define:
      some_tag:
        - define: foo
      some_other_tag:
        - add: [2, 3]
        - add: [!dag_prev , 4]
  expected:
    num_nodes: 5
    num_objects: 7
    tags: [dag, dm, select_base, some_tag, some_other_tag]
    results:
      some_tag:
        compare_to: foo
      some_other_tag:
        compare_to: 9


define_without_transformations:
  params:
    define:
      some_scalar: 5.123
      some_string: foobar
      some_dict:
        foo:
          bar: baz
        spam: fish

  expected:
    num_nodes: 3  # only one tag per definition!
    num_objects: 5
    tags: [dag, dm, select_base, some_scalar, some_string, some_dict]
    results:
      some_scalar:
        compare_to: 5.123
      some_string:
        compare_to: foobar
      some_dict:
        compare_to: {foo: {bar: baz}, spam: fish}


define_with_additional_tags:
  params:
    define:
      barfoo:
        - define: foo
          tag: foo
        - add: [bar, !dag_prev ]
      nine:
        - add: [2, 3]
          tag: five
        - add: [!dag_prev , 4]
          tag: also_nine  # will NOT be overwritten but added additionally
  expected:
    num_nodes: 6
    num_objects: 8
    tags: [dag, dm, select_base, foo, barfoo, five, nine, also_nine]
    results:
      foo:
        compare_to: foo
      barfoo:
        compare_to: barfoo
      five:
        compare_to: 5
      nine:
        compare_to: 9
      also_nine:
        compare_to: 9


define_with_dependencies:
  params:
    define:
      bar: bar
      foobar:
        - define: foo
        - add: [!dag_prev , !dag_tag bar]  # can use tag because bar < foo

  expected:
    results:
      foobar:
        compare_to: foobar



# Nested arguments ------------------------------------------------------------

nested_args:
  params:
    transform:
      - define: [1]
        tag: one
      - define: [2]
        tag: two
      - dict:
          one: !dag_tag one
          two: !dag_tag two
          nested:
            one: [!dag_tag one]
            two: [!dag_tag two]
            three: [3]
          as_list: [!dag_tag one, !dag_tag two, 3]
          as_nested_list: [[!dag_tag one, 2, 3], [1, !dag_tag two, 3], [1,2,3]]
        tag: nested

  expected:
    results:
      nested:
        type: dict
        compare_to:
          one: 1
          two: 2
          nested:
            one: [1]
            two: [2]
            three: [3]
          as_list: [1, 2, 3]
          as_nested_list: [[1,2,3], [1,2,3], [1,2,3]]


# Custom selection base and path prefixes -------------------------------------

custom_selection_base:
  params:
    base_transform:
      - getitem: [!dag_tag dm, some/path]
        tag: some_path
    select_base: some_path
    select:
      foo: foo
      bar:
        path: bar

    # Change verbosity
    verbosity: 0

  expected: &expected_custom_selection_base
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, some_path, foo, bar]
    node_hashes:
      - *hash_getitem_some_path
      - 828f7c086c39be3c6842aa4121d0926c
      - *hash_getitem_foo
    node_dependencies:
      - - *hash_dm
      - - *hash_getitem_some_path
      - - *hash_getitem_some_path
    cache_dir_available: false
    results:
      <<: *results_explicit_select


custom_selection_base_error_base_tag_not_found:
  params:
    base_transform:
      - getitem: [!dag_tag dm, some/path]
    select_base: some_path

  _raises: KeyError
  _match: "The tag 'some_path' cannot be used to set `select_base` because it is not available! .* Available tags: dag, dm, select_base"


select_path_prefix:
  params:
    select_path_prefix: some/path
    select:
      foo: foo
      bar:
        path: bar

  expected: &expected_select_path_prefix
    num_nodes: 2
    num_objects: 4
    tags: [dag, dm, select_base, foo, bar]
    node_hashes:
      - *hash_getitem_some_path_bar
      - *hash_getitem_some_path_foo
    node_dependencies:
      - - *hash_dm
      - - *hash_dm
    cache_dir_available: false
    results:
      <<: *results_explicit_select


select_path_prefix_trailing_slash:
  params:
    select_path_prefix: some/path/
    select:
      foo: foo
      bar:
        path: bar

  expected:
    <<: *expected_select_path_prefix


# Basic numerical operations --------------------------------------------------

# The following is named "basic", but already shows off a wide range of the
# TransformationDAG functionality, including object management and caching ...
basic_numerical_ops:
  params:
    select:
      zero_raw: data/zeros
    transform:
      - operation: increment
        args:
          - !dag_tag zero_raw
        tag: ones

      - operation: increment
        args:
          - !dag_tag ones
        tag: twos

      - operation: decrement
        args:
          - !dag_tag ones
        tag: zeros

      - operation: .T
        args:
          - !dag_prev
        tag: zeros_T

      - operation: .T
        args:
          - !dag_tag zero_raw
        tag: zero_raw_T

      - operation: .T
        args:
          - !dag_tag zero_raw
        tag: zero_raw_T2  # ... a duplicate of 'zero_raw_T' (except the tag)

    verbosity: 2
    file_cache_defaults:
      write:
        enabled: true

  expected:
    num_nodes: 7
    num_objects: 8  # not 9! Due to the duplicate Transformation
    tags: [dag, dm, select_base, zero_raw, ones, twos, zeros, zeros_T, zero_raw_T, zero_raw_T2]
    node_hashes:
      - &hash_select_zero_raw 67ab8f890b5cf94f67c16ad357ab8652
      - &hash_increment_zeros ed7dfc407e2f36d6d432c13e0ea594cc
      - 870381a48bfdfaf9200f57a3401c2497
      - 205a19938935266f5b357d248ddcc2a8
      - 6676a3e544caa4bfc3fcbf54cb2828a7
      - &hash_zero_raw_T f8860f940fe3f9578a6a6147cac807b1
      - *hash_zero_raw_T # from the duplicate transformation
    node_dependencies:
      - - *hash_dm
      - - *hash_select_zero_raw
      - - *hash_increment_zeros
      - 1
      - 1
      - 1
      - 1
    cache_dir_available: true
    cache_files:
      # - 67ab8f890b5cf94f67c16ad357ab8652.npy  # not cached (from select)
      - ed7dfc407e2f36d6d432c13e0ea594cc.npy
      - 870381a48bfdfaf9200f57a3401c2497.npy
      - 205a19938935266f5b357d248ddcc2a8.npy
      - 6676a3e544caa4bfc3fcbf54cb2828a7.npy
      - f8860f940fe3f9578a6a6147cac807b1.npy
    results:
      zero_raw:
        type: NumpyDataContainer
        attributes:
          path: /TestDM/data/zeros
          name: zeros
          mean: 0.
          shape: [2,3,4]
      ones:
        type: NumpyDataContainer
        attributes:
          path: /ed7dfc40
          mean: 1.
          shape: [2,3,4]
      twos:
        type: NumpyDataContainer
        attributes:
          path: /870381a4
          mean: 2.
          shape: [2,3,4]
      zeros:
        type: NumpyDataContainer
        attributes:
          path: /205a1993
          mean: 0.
          shape: [2,3,4]
      zeros_T:
        type: ndarray
        attributes:
          mean: 0.
          shape: [4,3,2]
      zero_raw_T: &results_zero_raw_T
        type: ndarray
        attributes:
          mean: 0.
          shape: [4,3,2]
      zero_raw_T2:
        <<: *results_zero_raw_T


binary_ops:
  params:
    select:
      zero_raw: data/zeros
      random_raw: data/random
    transform:
      - operation: add
        args:
          - !dag_tag zero_raw
          - !dag_tag random_raw
        tag: zero_plus_rand

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, zero_raw, random_raw, zero_plus_rand]
    node_hashes:
      - &hash_select_random 2ea71e0765cf6cad7fb97d44345c872b
      - *hash_select_zero_raw
      - 70f1ea60600680d52fe4e7a2b17bc29d
    node_dependencies:
      - - *hash_dm
      - - *hash_dm
      - - *hash_select_zero_raw
        - *hash_select_random
    cache_dir_available: false


duplicates_and_salted:
  params:
    select:
      zero_raw: data/zeros
    transform:
      - operation: increment
        args:
          - !dag_tag zero_raw
        tag: ones

      - operation: increment
        args:
          - !dag_tag zero_raw
        tag: also_ones

      - operation: increment
        args:
          - !dag_tag zero_raw
        tag: also_ones_but_salted
        salt: 123

  expected:
    num_nodes: 4
    num_objects: 5  # due to one duplicate transformation
    tags: [dag, dm, select_base, zero_raw, ones, also_ones, also_ones_but_salted]
    node_hashes:
      - *hash_select_zero_raw
      - *hash_increment_zeros
      - *hash_increment_zeros
      - d02fa3d2ee1fd03dcbbefb054a67bb61  # ... due to being salted


compute_only_a_subset:
  params:
    select:
      zero_raw: data/zeros
    transform:
      - operation: increment
        args:
          - !dag_tag zero_raw
        tag: ones

      - operation: increment
        args:
          - !dag_tag ones
        tag: twos

      - div: [1, 0]
        tag: would fail but is not computed

  compute_only: [zero_raw, twos]
  expected:
    computed_tags: [zero_raw, twos]


compute_all_does_not_include_private_tags:
  params:
    select:
      some_public_tag: data/zeros
      _some_private_tag: data/ones
      .another_private_tag:
        path: data/zeros
        transform: [increment]

    transform:
      - define: foo
        tag: another_public_tag

      - div: [1, 0]   # would fail, but is not tagged

  compute_only: all
  expected:
    computed_tags: [some_public_tag, another_public_tag]


force_compute:
  params:
    select:
      zero_raw:
        path: data/zeros
        transform:
          - pass: !dag_prev
            force_compute: true
    transform:
      - operation: increment
        args:
          - !dag_tag zero_raw
        tag: ones
        force_compute: true

      - operation: increment
        args:
          - !dag_tag ones
        tag: twos
        force_compute: ~

      - div: [1, 0]
        force_compute: true  # fails here because was force-computed

  compute_only: []
  expected:
    computed_tags: []

  _raises: DataOperationFailed
  _match: ZeroDivisionError
  _raises_on_compute: true



# Caching tests ---------------------------------------------------------------

numpy_and_xarray_data:
  skip_on_windows: True
  cache_dir_name: &shared_cache_dir shared_cache_dir
  params:
    file_cache_defaults:
      read: true  # ... but there is nothing
      write:
        enabled: true
        storage_options:
          raise_on_error: true

    select:
      zeros_raw: labelled_data/zeros
      random_raw: labelled_data/random

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones

      # Add a name
      - .rename: [!dag_prev , &da_name these_are_all_ones]
        tag: ones_named
      - .name: !dag_prev
        file_cache: false
        tag: ones_named_name

  expected:
    num_nodes: 5
    num_objects: 7
    tags: [dag, dm, select_base, zeros_raw, random_raw,
           ones, ones_named, ones_named_name]
    node_hashes:
      - &hash_select_random_raw 06a087440938ff577699351cf5c53e88
      - &hash_select_zeros_raw 4c42374387241560e73b5009e084c5ff
      - &hash_op_increment_zeros_raw 50749352642a34a09bfcda6742ee1963
      - b0359804f5e112f16a770a2eac04e45b
      - 3540fd4fa35bb6109ce5e75260f8ec65
    cache_dir_available: true
    cache_files:
      # ... only the results, ones and ones_named:
      - 50749352642a34a09bfcda6742ee1963.xrdc
      - b0359804f5e112f16a770a2eac04e45b.nc_da

    results:
      ones_named_name:
        compare_to: *da_name



numpy_and_xarray_data_2nd_run:
  skip_on_windows: True
  cache_dir_name: *shared_cache_dir
  params:
    file_cache_defaults:
      # read, don't write
      read: true
      write: false

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones
      - .rename: [!dag_prev , these_are_all_ones]
        tag: ones_named

      # Get the name to check that it was preserved
      - .name: !dag_prev
        file_cache: false
        tag: ones_named_name

      # Get from tree directly
      - getitem: [!dag_tag dm, cache/dag/50749352642a34a09bfcda6742ee1963]
        tag: ones_tree
      - getitem: [!dag_tag dm, cache/dag/b0359804f5e112f16a770a2eac04e45b]
        tag: ones_named_tree

  expected:
    num_nodes: 6
    num_objects: 8
    tags: [dag, dm, select_base, zeros_raw,
           ones, ones_named, ones_named_name, ones_tree, ones_named_tree]
    cache_dir_available: true
    cache_files:
      - 50749352642a34a09bfcda6742ee1963.xrdc
      - b0359804f5e112f16a770a2eac04e45b.nc_da

    results:
      ones_named_name:
        compare_to: *da_name


numpy_and_xarray_data_3rd_run:
  skip_on_windows: True
  cache_dir_name: *shared_cache_dir
  params:
    file_cache_defaults:
      # Read but still overwrite existing file
      read: true
      write:
        enabled: true
        allow_overwrite: true

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones
      - .rename: [!dag_prev , these_are_all_ones]
        tag: ones_named

      # Get the name to check that it was preserved
      - .name: !dag_prev
        file_cache: false
        tag: ones_named_name

  expected:
    num_nodes: 4
    num_objects: 6
    tags: [dag, dm, select_base, zeros_raw, ones, ones_named, ones_named_name]
    cache_dir_available: true
    cache_files:
      - 50749352642a34a09bfcda6742ee1963.nc_da
      - b0359804f5e112f16a770a2eac04e45b.nc_da

    results:
      ones_named_name:
        compare_to: *da_name


file_cache_pickle_data:
  params:
    select:
      some_dict: objects/some_dict

    transform:
      - operation: getattr
        args: [!dag_tag some_dict, _data]
        tag: dict_data
        file_cache:
          write: true

  expected:
    num_nodes: 2
    num_objects: 4
    tags: [dag, dm, select_base, some_dict, dict_data]
    cache_dir_available: true
    cache_files:
      - 047e6ff6c13f875ce6d7e4c84ac6b964.pkl


file_cache_kwargs_to_transformation:
  params:
    file_cache_defaults:
      write:
        enabled: false

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones
      - increment: [!dag_tag ones]
        tag: twos
        file_cache:
          write:
            enabled: true
            always: true

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, zeros_raw, ones, twos]
    node_hashes:
      - *hash_select_zeros_raw
      - *hash_op_increment_zeros_raw
      - 1c7a39fea5901c7c233849b57c3028eb
    cache_dir_available: true
    cache_files:
      - 1c7a39fea5901c7c233849b57c3028eb.xrdc  # tag twos


file_cache_kwargs_to_select:
  params:
    file_cache_defaults:
      read: true
      write: false

    select:
      zeros_raw: labelled_data/zeros
      random_plus_minus:
        path: labelled_data/random
        transform:
          - increment
          - decrement: []
            with_previous_result: true
            file_cache:
              write: true

    transform: []

  expected:
    num_nodes: 4
    num_objects: 6
    tags: [dag, dm, select_base, zeros_raw, random_plus_minus]
    node_hashes:
      - *hash_select_random_raw
      - f461fcc1d4710900ce4328ef889da7d5
      - 2ead911e70ecd6bce631ce02a68e7a9e
      - *hash_select_zeros_raw
    cache_dir_available: true
    cache_files:
      - 2ead911e70ecd6bce631ce02a68e7a9e.xrdc  # random after decrement


file_cache_object_size:
  params:
    file_cache_defaults:
      write:
        enabled: true
        min_size: 1048576  # 1M >> labelled_data/zeros

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones
      - increment: [!dag_tag ones]
        tag: twos
        file_cache:
          write:
            min_size: 1

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, zeros_raw, ones, twos]
    node_hashes:
      - *hash_select_zeros_raw
      - *hash_op_increment_zeros_raw
      - 1c7a39fea5901c7c233849b57c3028eb
    cache_dir_available: true
    cache_files:
      - 1c7a39fea5901c7c233849b57c3028eb.xrdc  # tag twos


file_cache_min_compute_time:
  params:
    file_cache_defaults:
      write:
        enabled: true
        min_compute_time: 42.
        # much larger than actual compute time

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones
      - increment: [!dag_tag ones]
        tag: twos
        file_cache:
          write:
            min_compute_time: 0.
            min_cumulative_compute_time: ~

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, zeros_raw, ones, twos]
    node_hashes:
      - *hash_select_zeros_raw
      - *hash_op_increment_zeros_raw
      - 1c7a39fea5901c7c233849b57c3028eb
    cache_dir_available: true
    cache_files:
      - 1c7a39fea5901c7c233849b57c3028eb.xrdc  # tag twos


file_cache_min_cumulative_compute_time:
  params:
    file_cache_defaults:
      write:
        enabled: true
        min_cumulative_compute_time: 42.

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones
      - increment: [!dag_tag ones]
        tag: twos
        file_cache:
          write:
            min_cumulative_compute_time: 0.

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, zeros_raw, ones, twos]
    node_hashes:
      - *hash_select_zeros_raw
      - *hash_op_increment_zeros_raw
      - 1c7a39fea5901c7c233849b57c3028eb
    cache_dir_available: true
    cache_files:
      - 1c7a39fea5901c7c233849b57c3028eb.xrdc  # tag twos


file_cache_always_read:
  params:
    file_cache_defaults:
      read:
        enabled: true
        always: true
        load_options:
          chunks: this is an invalid argument  # to check that it's invoked
      write:
        enabled: true
        always: true

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        salt: 123
        tag: ones
      - increment: [!dag_tag ones]
        salt: 123
        tag: twos

  _raises: DataLoadingError  # ... because of the invalid `chunks` argument
  _raises_on_compute: true
  _match: chunks


file_cache_always_read_without_memory_cache:
  params:
    file_cache_defaults:
      read:
        enabled: true
        always: true
        load_options:
          chunks: this is an invalid argument  # to check that it's invoked
      write:
        enabled: true
        always: true

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        salt: 123
        memory_cache: true
        tag: ones
      - increment: [!dag_tag ones]
        salt: 123
        memory_cache: false
        tag: twos

  _raises: DataLoadingError  # ... because of the invalid `chunks` argument
  _raises_on_compute: true
  _match: chunks


file_cache_invariant_hash:
  params:
    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones_v1
        file_cache:
          write: false
          read: false
      - increment: [!dag_tag zeros_raw]
        tag: ones_v2
        file_cache:
          write: true
      - increment: [!dag_tag zeros_raw]
        tag: ones_v3
        file_cache:
          foo: bar  # ... is ignored! Which is intentional
      - increment: [!dag_tag zeros_raw]
        tag: ones_v4
        salt: 123
        file_cache:
          read: true

  expected:
    num_nodes: 5
    num_objects: 5
    tags: [dag, dm, select_base, zeros_raw, ones_v1, ones_v2, ones_v3, ones_v4]
    node_hashes:
      - *hash_select_zeros_raw
      - *hash_op_increment_zeros_raw
      - *hash_op_increment_zeros_raw
      - *hash_op_increment_zeros_raw
      - 800f018e981d6bdca4a5bee0d5517acf
    cache_dir_available: false


file_cache_with_callable_result:
  params:
    transform:
      - import: [numpy, array]
        file_cache:
          write: false  # ... this works
        tag: nocache
        salt: 123
      - import: [numpy.random, randint]
        file_cache:
          write:
            enabled: true
            storage_options:
              attempt_pickling: true
              raise_on_error: true
        tag: numpy.random.randint

  expected:
    num_nodes: 2
    num_objects: 4
    tags: [dag, dm, select_base, nocache, numpy.random.randint]
    cache_dir_available: true
    cache_files:  # ... only one!
      - 041086b927535557204b1a16c9026be2.pkl


file_cache_netcdf4_coercion:
  params:
    transform:
      - operation: np.array
        args: [[1,2,3]]
        kwargs: {dtype: uint64}   # supported by netcdf-4 -> not coerced
        tag: arr_uint64
      - xr.DataArray: {data: !dag_tag arr_uint64}
        file_cache:
          read: true
          write:
            enabled: true
            storage_options:
              attempt_pickling: true
        tag: arr_uint64_write
      - xr.DataArray: {data: !dag_tag arr_uint64}
        file_cache:
          read: true
        tag: arr_uint64_read

  expected:
    num_nodes: 3
    num_objects: 4
    tags: [dag, dm, select_base, arr_uint64, arr_uint64_write, arr_uint64_read]
    cache_dir_available: true
    cache_files:
      - ebcd59f88bf3f5a4761d16ef53a6c8b9.nc_da


file_cache_pkl_fallback:
  params:
    transform:
      - operation: np.array
        args: [[1,2,3,4]]
        kwargs: {dtype: complex128}  # not supported by netcdf4
        tag: arr
      - xr.DataArray: {data: !dag_tag arr}
        file_cache:
          read: true
          write:
            enabled: true
            storage_options:
              attempt_pickling: true
        tag: arr_write
      - xr.DataArray: {data: !dag_tag arr}
        file_cache:
          read: true
        tag: arr_read

  expected:
    num_nodes: 3
    num_objects: 4
    tags: [dag, dm, select_base, arr, arr_write, arr_read]
    cache_dir_available: true
    cache_files:
      # - <hash>.nc_da from failed storage function call does _not_ exist
      - a66004adbb0bee08b0591fbd15273be2.pkl  # .pkl shows fallback was used


file_cache_with_module_as_result:  # module pickling is supported by dill
  params:
    transform:
      - import: numpy
        file_cache:
          write: false  # ... this works
        tag: nocache
        salt: 123
      - import: numpy.random
        file_cache:
          write:
            enabled: true
            storage_options:
              attempt_pickling: true
              raise_on_error: true
        tag: numpy.random

  expected:
    tags: [dag, dm, select_base, nocache, numpy.random]
    cache_dir_available: true
    cache_files:
      - b9fe3ce697bbbd431ce5e7f70297d80f.pkl


file_cache_error_pkl_function:
  params:
    transform:
      - operation: getitem
        args: [!dag_tag dm, objects/some_list]
        tag: some_list
        file_cache:
          write:
            enabled: true
            storage_options:
              attempt_pickling: false  # --> no cache file
              raise_on_error: true

      - operation: getitem
        args: [!dag_tag dm, objects/some_dict]
        tag: some_dict
        file_cache:
          write:
            enabled: true
            storage_options:
              # no argument -> will attempt pickling -> cache file
              raise_on_error: false

      - operation: getitem
        args: [!dag_tag dm, objects/some_func]  # supported by dill
        tag: some_func
        file_cache:
          write:
            enabled: true
            storage_options:
              raise_on_error: true

  # NOTE ... there seems to be some crosstalk between objects/some_func, which
  #      should actually be pickleable, and the custom implementation of
  #      UnpickleableString for bad_objects/some_str, which should really not
  #      be pickleable. For whatever weird reason.
  #      Anyway, this scenario is quite made-up, so although this case should
  #      NOT fail, let's handle it as if it _was_ failing ... can't be bothered
  # expected:
  #   tags: [dag, dm, select_base, some_list, some_dict, some_func]
  #   cache_dir_available: true
  #   cache_files:
  #     # - c106031ee0089b2d4d7efd4a7cb09cc6.pkl  # the list
  #     - d64ae71435836020d3d33223baf7bb25.pkl    # the dict
  #     - 6c3f280c8f1a4aa64221d609a5aa54f3.pkl    # the function
  _raises: RuntimeError
  _raises_on_compute: true
  _match: I refuse to be pickled  # How does objects/some_func do this?!?!?!


file_cache_error_unpickleable:
  params:
    transform:
      - operation: getitem
        args: [!dag_tag dm, bad_objects/some_string]
        tag: i_cannot_be_pickled
        file_cache:
          write:
            enabled: true
            storage_options:
              raise_on_error: true

  _raises: RuntimeError
  _raises_on_compute: true
  _match: I refuse to be pickled


file_cache_error_file_already_loaded:
  # Use the shared cache to lead to a conflict, that would normally raise ...
  # ... but does not here, because the cache file was already loaded and the
  # loading mechanism is thus not invoked another time.
  cache_dir_name: *shared_cache_dir
  params:
    file_cache_defaults:
      # read and overwrite
      read:
        enabled: true
        load_options:
          exists_action: raise
      write:
        enabled: true
        allow_overwrite: true

    select:
      zeros_raw: labelled_data/zeros

    transform:
      - increment: [!dag_tag zeros_raw]
        tag: ones


file_cache_error_attempting_dm_select_cache:
  params:
    select:
      zeros_raw:
        path: labelled_data/zeros
        file_cache:
          write: true
    transform: ~

  _raises: ValueError
  _match: For selection from the selection base, the file cache is always disabled.


file_cache_error_writing_groups:
  params:
    transform:
      - operation: getitem
        args: [!dag_tag dm, some/path]
        tag: some_group
        file_cache:
          write: true

      - operation: getitem
        args: [!dag_tag dm, labelled_data]
        tag: some_group_to_be_cached
        file_cache:
          read: false
          write:
            enabled: true
            always: true
            storage_options:
              ignore_groups: false

  _raises: NotImplementedError
  _raises_on_compute: true
  _match: Cannot currently write dantro groups .* transformation resulting .*


file_cache_error_in_save_func:
  params:
    transform:
      - operation: getitem
        args: [!dag_tag dm, labelled_data/zeros]
        tag: zeros
        file_cache:
          write:
            enabled: true
            always: true
            storage_options:
              raise_on_error: false
              some_invalid_argument: asdf
      - operation: getitem
        args: [!dag_tag dm, labelled_data/random]
        tag: random
        file_cache:
          write:
            enabled: true
            always: true
            storage_options:
              raise_on_error: true
              some_invalid_argument: asdf

  _raises: RuntimeError
  _raises_on_compute: true
  _match: Failed saving transformation cache file .* using storage function



# Errors ----------------------------------------------------------------------

error_tag_already_exists:
  params:
    select:
      zero_raw: data/zeros
      random_raw: data/random
    transform:
      - operation: add
        args:
          - !dag_tag zero_raw
          - !dag_tag random_raw
        tag: random_raw
  _raises: ValueError
  _match: Tag 'random_raw' already exists! Choose a different one.


error_missing_tag:
  params:
    transform:
      - add: [1, !dag_tag foo]  # foo is not *yet* defined
      - define: 2
        tag: foo
  _raises: MissingDAGTag
  _match: Could not find tag 'foo'! Available


error_bad_node_idx:
  params:
    transform:
      - add: [1, 2]  # foo is not *yet* defined
      - define: [!dag_node -10]
        tag: foo
  _raises: MissingDAGNode
  _match: list index out of range


error_bad_operation_name:
  params:
    transform:
      - operation: i_do_not_exist
        tag: result
  _raises: BadOperationName
  _raises_on_compute: true
  _match: Could not find an operation or meta-operation named 'i_do_not_exist'!


error_bad_operation_name_with_meta_operations:
  params:
    meta_operations:
      my_meta_op:
        - add: [!arg 0, !arg 1]
    transform:
      - operation: i_do_not_exist
        tag: result
  _raises: ValueError
  _raises_on_compute: true
  _match: my_meta_op  # includes name of available meta-operations


error_bad_reference_within_meta_operation:
  params:
    meta_operations:
      my_meta_op:
        - add: [!arg 0, !arg 1]
        - add: [!dag_prev , !dag_tag foo]  # foo not *yet* defined
        - define: foo
          tag: foo
    transform:
      - my_meta_op: [spam, fish]
        tag: result
  _raises: MissingDAGReference
  _match: Failed resolving reference .* 'my_meta_op::foo' via reference stack


error_bad_compute_only_tag:
  params:
    transform:
      - add: [1, 2]
        tag: result
  compute_only: [bad_tag]
  _raises: ValueError
  _raises_on_compute: true
  _match: Some of the tags specified



# Operation Hooks -------------------------------------------------------------

op_hook_deactivated:
  params:
    select:
      some_zeros: data/zeros
    transform:
      - increment: !dag_tag some_zeros
        tag: some_ones
      - operation: expression
        args: [some_zeros + some_ones + 2.]
        kwargs:
          symbols:
            some_zeros: !dag_tag some_zeros
            some_ones: !dag_tag some_ones
        tag: result
        ignore_hooks: true

  expected:
    num_nodes: 3
    num_objects: 5
    tags: [dag, dm, select_base, some_zeros, some_ones, result]
    results:
      result:
        type: ndarray
        attributes:
          mean: 3.
          shape: [2,3,4]


op_hook_expression_simple:
  params:
    select: &op_hook_expression_select
      some_zeros: data/zeros
      some_ones:
        path: data/zeros
        with_previous_result: true
        transform:
          - increment
    transform:
      - expression: some_zeros + some_ones + 2.
        tag: result

  expected:
    num_nodes: 4
    num_objects: 5
    tags: [dag, dm, select_base, some_zeros, some_ones, result]
    results:
      result:
        type: ndarray
        attributes:
          mean: 3.
          shape: [2,3,4]


op_hook_expression_advanced:
  params:
    select:
      <<: *op_hook_expression_select
    transform:
      # partial symbol replacement
      - operation: expression
        args: [(some_zeros + 1) * (10**exponent)]
        kwargs:
          symbols:
            exponent: 2
        tag: result1
      # implicitly with previous result
      - expression: prev * 0.01 + some_ones
        tag: result2
      # not failing with explicitly given previous result
      - expression: previous_result * 0 + prev + result1
        with_previous_result: true
        tag: result3

  expected:
    num_nodes: 6
    num_objects: 7
    tags: [dag, dm, select_base, some_zeros, some_ones, result1, result2, result3]
    results:
      result1:
        type: ndarray
        attributes:
          mean: 100.
          shape: [2,3,4]
      result2:
        type: ndarray
        attributes:
          mean: 2.
          shape: [2,3,4]
      result3:
        type: ndarray
        attributes:
          mean: 102.
          shape: [2,3,4]


op_hook_expression_bad_hook:
  params:
    select:
      <<: *op_hook_expression_select
    transform:
      # will fail to replace symbols in the hook, but will succeed overall
      - operation: expression
        args: [some_zeros.ndim]  # causes AttributeError: Symbol has no .ndim
        kwargs:
          symbols:
            some_zeros: !dag_tag some_zeros
        tag: result
  expected:
    num_nodes: 4
    num_objects: 5
    tags: [dag, dm, select_base, some_zeros, some_ones, result]
    results:
      result:
        type: float64
        attributes:
          ndim: 0


op_hook_expression_type_error:
  params:
    select:
      <<: *op_hook_expression_select
    transform:
      # bad arguments; will fail not in the hook but when applying operation
      - expression: [foo, bar, baz]
        tag: result
  _raises: RuntimeError
  _raises_on_compute: true
  _match: takes 1 positional argument but 3 were given


op_hook_expression_bad_expression:
  params:
    select:
      <<: *op_hook_expression_select
    transform:
      # bad expression
      - expression: i will not parse [1, 2, 3].foo
        tag: result
  _raises: RuntimeError
  _raises_on_compute: true
  _match: Failed parsing expression.*invalid syntax



# Meta-operations -------------------------------------------------------------

meta_ops_getitem_alias:
  params:
    meta_operations:
      getitem_alias:
        transform:
          - operation: getitem
            args: [!arg 0, !arg 1]

    transform:
      - operation: getitem_alias
        args:
          - !dag_tag dm
          - some/path
      - operation: getitem_alias
        args:
          - !dag_node -1
          - foo
        tag: foo

      - operation: getitem_alias
        args:
          - !dag_tag dm
          - some/path/bar
        tag: bar

  expected: &meta_ops_getitem_expected
    num_nodes: 6
    num_objects: 8
    meta_operations:
      getitem_alias:
        num_nodes: 1
        num_args: 2
        kwarg_names: []
    tags: [dag, dm, select_base, foo, bar]
    node_hashes:
      - *hash_getitem_some_path
      - &hash_pass_after_getitem_some_path  dfdab46460b61e55bf7b7d9755ef020f
      - &hash_getitem_foo_after_meta_op     ee2f0913bae223d2a9d021515e32c99b
      - &hash_pass_after_getitem_foo        aea396cb2d3db91a96a0a7ad29493b19
      - *hash_getitem_some_path_bar
      - &hash_pass_after_getitem_bar        2c46d76d13198b58e7dab6726094aee3
    node_dependencies:
      - - *hash_dm                                   # 0 -> DataManager
      - - *hash_getitem_some_path                    # 1 -> 0
      - - *hash_pass_after_getitem_some_path         # 2 -> 1
      - - *hash_getitem_foo_after_meta_op            # 3 -> 2
      - - *hash_dm                                   # 4 -> DataManager
      - - *hash_getitem_some_path_bar                # 5 -> 4
    cache_dir_available: false
    results: *results_explicit_select


meta_ops_getitem_from_dm:
  params:
    meta_operations:
      getitem_from_dm:
        - operation: getitem
          args:
            - !dag_tag dm   # Special tag, is NOT removed!
            - !arg 0
    transform:
      - getitem_from_dm: some/path/foo
        tag: foo
      - getitem_from_dm: some/path/bar
        tag: bar

  expected:
    <<: *meta_ops_getitem_expected

    num_nodes: 4
    num_objects: 6
    meta_operations:
      getitem_from_dm:
        num_nodes: 1
        num_args: 1
        kwarg_names: []

    node_hashes:
      - *hash_getitem_some_path_foo
      - 613abd2c260f94a60a76838c58c7c82c  # pass
      - *hash_getitem_some_path_bar
      - 2c46d76d13198b58e7dab6726094aee3  # pass
    node_dependencies:
      - - *hash_dm
      - - *hash_getitem_some_path_foo
      - - *hash_dm
      - - *hash_getitem_some_path_bar


meta_ops_in_base_transform:
  params:
    meta_operations:
      getitem_alias:
        transform:
          - operation: getitem
            args: [!arg 0, !arg 1]

    base_transform:
      - operation: getitem_alias
        args:
          - !dag_tag dm
          - some/path
        tag: some_path
    select_base: some_path

    select:
      foo: foo
      bar: bar

  expected:
    <<: *meta_ops_getitem_expected
    num_nodes: 4
    num_objects: 6
    tags: [dag, dm, select_base, some_path, foo, bar]
    node_hashes: ~
    node_dependencies: ~


meta_ops_getitem_from_some_path:
  params:
    meta_operations:
      getitem_from_some_path:
        select:
          some_path: some/path
        transform:
          - getitem:
              - !dag_tag some_path
              - !arg 0

    transform:
      - getitem_from_some_path: foo
        tag: foo
      - getitem_from_some_path: bar
        tag: bar

  expected:
    num_nodes: 6
    num_objects: 7
    node_hashes:
      - *hash_getitem_some_path
      - 39175b65f33504b4482667416f144a42
      - 17156e383f627bc3cb1202b6835b05cf  # pass
      - *hash_getitem_some_path
      - 828f7c086c39be3c6842aa4121d0926c
      - c012ee92159bb4e28b9029216a935655  # pass
    meta_operations:
      getitem_from_some_path:
        num_nodes: 2
        num_args: 1
        kwarg_names: []
    tags: [dag, dm, select_base, foo, bar]
    results: *results_explicit_select


meta_ops_simple_chain:
  params:
    meta_operations:
      add_ten:
        - add: [!arg 0, 1]
        - add: [!dag_prev , 2]
          tag: after_adding_two  # Can also use tags for chaining
        - add: [!dag_tag after_adding_two, 3]
        - add: [!dag_prev , 4]

    transform:
      - add_ten: 0
        tag: ten
      - add_ten: 32
        tag: fourtytwo
      - add_ten: -9.5
        tag: pointfive

  expected:
    num_nodes: 15
    num_objects: 17
    tags: [dag, dm, select_base, ten, fourtytwo, pointfive]

    results:
      ten:
        type: int
        compare_to: 10
      fourtytwo:
        type: int
        compare_to: 42
      pointfive:
        type: float
        compare_to: .5


meta_ops_with_kwargs:
  params:
    meta_operations:
      hello:
        - .format: "Hello, {first} {last}!"
          kwargs:
            first: !kwarg first_name
            last: !kwarg last_name

    transform:
      - hello:
          first_name: Foo
          last_name: Bar
        tag: hello_foobar
      - hello:
          first_name: cruel
          last_name: world
        tag: hello_cruel_world

  expected:
    num_nodes: 4
    num_objects: 6
    tags: [dag, dm, select_base, hello_foobar, hello_cruel_world]
    results:
      hello_foobar:
        compare_to: "Hello, Foo Bar!"
      hello_cruel_world:
        compare_to: "Hello, cruel world!"


meta_ops_mixed_args_and_kwargs:
  params:
    meta_operations:
      weird_define:
        - define: [[!arg 0, !arg 2, !kwarg foo, !arg 1, !kwarg bar]]
    transform:
      - weird_define: [0, 1, 2]
        kwargs:
          foo: foo
          bar: bar
        tag: weird_list

  expected:
    results:
      weird_list:
        compare_to: [0, 2, foo, 1, bar]


meta_ops_internal_tags:
  params:
    meta_operations:
      left_minus_right_times_two:
        - add: [!kwarg l1, !kwarg l2]
          tag: left
        - add: [!kwarg r1, !kwarg r2]
          tag: right
        - sub: [!dag_tag left, !dag_tag right]
          tag: difference
        - mul: [!dag_tag difference, 2]

    transform:
      - left_minus_right_times_two: # [(2+3) - (10+1)] * 2
          l1: 2
          l2: 3
          r1: 10
          r2: 1
        tag: res1
      - left_minus_right_times_two: # [(4+3) - (2+1)] * 2
          l1: 4
          l2: 3
          r1: 2
          r2: 1
        tag: res2

  expected:
    meta_operations:
      left_minus_right_times_two:
        num_nodes: 4
        num_args: 0
        kwarg_names: [l1, l2, r1, r2]
    results:
      res1:
        compare_to: -12
      res2:
        compare_to: 8


meta_ops_nested:
  params:
    meta_operations:
      multi_add:
        - add: [!arg 0, !arg 1]
        - add: [!dag_prev , !arg 2]
      multi_mul:
        - mul: [!arg 0, !arg 1]
        - mul: [!dag_prev , !arg 2]
      nested_mops:
        - multi_add: [!kwarg s1, !kwarg s2, !kwarg s3]
        - multi_add: [!dag_prev , !kwarg s4, !kwarg s5]
          tag: my_sum
        - multi_mul: [!kwarg m1, !kwarg m2, !kwarg m3]
          tag: my_prod
        - sub: [!dag_tag my_sum , !dag_tag my_prod]

    transform:
      - nested_mops:  # ((1+2+3)+4+5) - (2*2*2) = 15 - 8 = 7
          s1: 1
          s2: 2
          s3: 3
          s4: 4
          s5: 5
          m1: 2
          m2: 2
          m3: 2
        tag: result

  expected:
    results:
      result:
        compare_to: 7


meta_ops_deeply_nested:
  params:
    meta_operations:
      # ... deliberately complicated and nested in order to test that the
      # nesting of meta-operations and duplicate use of tags works correctly.
      # This asserts the functionality of the reference stack.
      base2:
        - add: [1, 1]
          tag: two
        - pow: [!dag_tag two, !arg 0 ]
      base3:
        - base2: [2]
          tag: two
        - div: [!dag_tag two, !dag_tag two]
          tag: one
        - sub: [!dag_tag two , !dag_tag one]
          tag: three
        - pow: [!dag_tag three, !arg 0 ]
      base5:
        - base3: [1]
          tag: three
        - base2: [1]
          tag: two
        - add: [!dag_tag two, !dag_tag three]
          tag: five
        - pow: [!dag_tag five, !arg 0 ]
      base7:
        - base2: [1]
          tag: two
        - base2: [2]
          tag: four
        - base3: [0]
        - add: [!dag_tag two, !dag_prev ]
          tag: three
        - add: [!dag_tag four, !dag_tag four]
          tag: eight
        - sub: [!dag_tag four, !dag_tag three]
          tag: one
        - sub: [!dag_tag eight, !dag_tag one]
          tag: seven
        - pow: [!dag_tag seven, !arg 0 ]
      multiply_some_primes:
        - base2: [!kwarg twos]
          tag: twos
        - base3: [!kwarg threes]
          tag: threes
        - base5: [!kwarg fives]
          tag: fives
        - base7: [!kwarg sevens]
          tag: sevens
        - np.:
            - prod
            - - !dag_tag twos
              - !dag_tag threes
              - !dag_tag fives
              - !dag_tag sevens

    transform:
      - multiply_some_primes:  # 2^2 * 3^3 * 5^5 * 7^7 = 277 945 762 500
          twos: 2
          threes: 3
          fives: 5
          sevens: 7
        tag: result

  expected:
    results:
      result:
        compare_to: 277945762500


meta_ops_args_and_kwargs_with_defaults:
  params:
    meta_operations:
      weird_define:
        - define:
          - - !arg [0, 0]
            - !arg [2, 2]
            - !kwarg [foo, foo]
            - !arg [1, 1]
            - !kwarg [bar, bar]
    transform:
      - weird_define: []  # no args needed
        tag: weird_list

      - weird_define
      - pass: !dag_prev
        tag: weird_list2

  expected:
    results:
      weird_list:
        compare_to: &weird_list_expected [0, 2, foo, 1, bar]
      weird_list2:
        compare_to: [*weird_list_expected, 2, foo, 1, bar]


meta_ops_args_and_kwargs_with_fancy_defaults:
  params:
    meta_operations:
      weird_define:
        - define:
          - - !arg [0, zero]
            - !arg [2, [zero, one, two]]
            - !kwarg [foo, {some: dict, even: {with: {nested: entries}}}]
            - !arg [1, one]
            - !kwarg [bar, foo]
            - !kwarg [bar, FOO]  # note the different fallback
            - {bar: !kwarg baz}
    transform:
      - weird_define:
          baz: BAZ
        tag: weird_list

  expected:
    results:
      weird_list:
        compare_to:
          - zero
          - [zero, one, two]
          - {some: dict, even: {with: {nested: entries}}}
          - one
          - foo
          - FOO  # different fallback is implicitly possible
          - {bar: BAZ}


meta_ops_multiple_placeholder_use:
  params:
    meta_operations:
      sum_by_absdiff:
        - add: [!arg 0, !arg 1]
          tag: sum

        - sub: [!arg 0, !arg 1]
        - np.abs: !dag_prev
          tag: absdiff

        - div: [!dag_tag sum, !dag_tag absdiff]

      get_diff:
        - getitem: [!arg 0, !arg [1, foo]]
          tag: foo
        - getitem: [!arg 0, !arg [2, bar]]
          tag: bar
        - sub: [!dag_tag foo, !dag_tag bar]

    transform:
      - np.array: [[1, 2, 3]]
        tag: arr1
      - np.array: [[2, 4, 6]]
        tag: arr2
      - xr.DataArray: !dag_prev
        kwargs:
          dims: [x]
          coords:
            x: !range [3]
        tag: darr2

      - sum_by_absdiff: [9, 11]
        tag: ten

      - sum_by_absdiff: [!dag_tag arr1, !dag_tag arr2]
      - sum: !dag_prev
        tag: nine

      - dict:
          foo: 50
          bar: 8
          hundred: 100
          minus_one: -1
          arr1: !dag_tag arr1
          arr2: !dag_tag arr2
          darr2: !dag_tag darr2
        tag: named_numbers
      - get_diff: !dag_tag named_numbers
        tag: fourtytwo
      - get_diff: [!dag_tag named_numbers, hundred, minus_one]
        tag: hundred_and_one
      - get_diff: [!dag_tag named_numbers, minus_one, hundred]
        tag: ninetynine

      # again with mutable objects
      - get_diff: [!dag_tag named_numbers, arr2, arr1]
      - sum: !dag_prev
        tag: six

      - get_diff: [!dag_tag named_numbers, darr2, darr2]
      - list: !dag_prev
        tag: zeros

      # and with data tree objects
      - get_diff: [!dag_tag dm, path/to/more_data, path/to/some_data]
      - .sum: !dag_prev
        tag: twentyfive

  expected:
    results:
      ten:
        compare_to: 10
      nine:
        compare_to: 9   # np.sum([3,6,9] / [1,2,3])
      fourtytwo:
        compare_to: 42
      hundred_and_one:
        compare_to: 101
      ninetynine:
        compare_to: -101
      six:
        compare_to: 6
      zeros:
        compare_to: [0, 0, 0]
      twentyfive:
        compare_to: 25

meta_ops_dag_prev_use:
  params:
    meta_operations:
      my_add:
        - add: [0, !arg 0]
        - add: [!dag_prev , !arg 1]
      multi_add:
        - my_add: [!arg 0, !arg 1]
        - my_add: [!dag_prev , !arg 2]
      multi_add_named:
        - multi_add: [!kwarg s1, !kwarg s2, !kwarg s3]
        - multi_add: [!dag_prev , !kwarg s4, !kwarg s5]
        - multi_add: [!kwarg s6, !dag_prev , !kwarg s7]

    transform:
      - define: 4

      - multi_add_named:     # (((1+2+3) + 4+5) + 6+7) = 15 + 13 = 28
          s1: 1
          s2: 2
          s3: 3
          s4: !dag_prev      # needs to be evaluated on this scope!
          s5: 5
          s6: 6
          s7: 7
        tag: result

  expected:
    results:
      result:
        compare_to: 28

# .. meta operation errors ....................................................

meta_ops_err_name_exists:
  params:
    meta_operations:
      getitem: {}

  _raises: ValueError
  _match: An operation or meta-operation with the name 'getitem' already exists


meta_ops_err_no_specs:
  params:
    meta_operations:
      foo: {}

  _raises: MetaOperationError
  _match: need to contain at least one transformation


meta_ops_err_non_contiguous_args:
  params:
    meta_operations:
      some_mop:
        - define: [[!arg 0, !arg 1, !arg 3]]

  _raises: MetaOperationError
  _match: were not contiguous! .* for all integers from 0 to 3


meta_ops_err_too_few_args:
  params:
    meta_operations:
      weird_define:
        - define: [[!arg 0, !arg 3, !arg 1, !arg 2]]
    transform:
      - weird_define: [foo, bar]

  _raises: MetaOperationInvocationError
  _match: requires at least 4 positional argument\(s\) but got only 2


meta_ops_err_too_many_args:
  params:
    meta_operations:
      weird_define:
        - define: [[!arg 0, !arg [3, three], !arg 1, !arg 2]]
    transform:
      - weird_define: [foo, bar, baz, spam, fish]

  _raises: MetaOperationInvocationError
  _match: expects 3 required and 1 optional .* but got 5


meta_ops_err_missing_kwarg:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg bar, !arg 0, !kwarg baz]]
    transform:
      - operation: weird_define
        args: [zero]
        kwargs:
          foo: foo
          bar: bar
          BAZ: BAZ  # wrong

  _raises: MetaOperationInvocationError
  _match: misses the following required keyword argument.* baz


meta_ops_err_too_many_kwargs:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg bar, !arg 0, !kwarg baz]]
    transform:
      - operation: weird_define
        args: [zero]
        kwargs:
          foo: foo
          bar: bar
          baz: baz
          BAZ: BAZ  # wrong

  _raises: MetaOperationInvocationError
  _match: got superfluous keyword arguments.*BAZ


meta_ops_err_ambiguous_arg_fallbacks:
  params:
    meta_operations:
      my_operation:
        - define: !arg [0, zero]
        - define: !arg [1, one]
        - define: !arg 0

  _raises: MetaOperationSignatureError
  _match: not clearly identifiable as optional


meta_ops_err_ambiguous_kwarg_fallbacks:
  params:
    meta_operations:
      my_operation:
        - define: !kwarg [foo, FOO]
        - define: !kwarg [bar, BAR]
        - define: !kwarg bar

  _raises: MetaOperationSignatureError
  _match: not clearly identifiable as optional


meta_ops_err_arg_required_optional_order:
  params:
    meta_operations:
      my_operation:
        - define: !arg 0
        - define: !arg 1
        - define: [!arg 2, !arg 1]
        - define: !arg [3, three]
        - define: !arg 4

  _raises: MetaOperationSignatureError
  _match: come strictly after required positional arguments


meta_ops_err_external_tags:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg bar, !dag_tag spam]]
          tag: foobarspam
        - pass: !dag_tag foobarspam

  _raises: MetaOperationError
  _match: not defined as part of the meta-operation .* Within a meta-operation, only internally-defined tags \(foobarspam\) or special tags \(dag, dm, select_base\) can be used


meta_ops_err_tags_in_arg_fallback:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg [bar, {foo: bar, baz: !dag_tag spam}]]]
          tag: foobar
        - pass: !dag_tag foobar

  _raises: MetaOperationError
  _match: may not contain tags or any other kind of placeholder


meta_ops_err_tags_in_arg_fallback2:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg [bar, {foo: bar, baz: !arg 0}]]]
          tag: foobar
        - pass: !dag_tag foobar

  _raises: MetaOperationError
  _match: may not contain tags or any other kind of placeholder


meta_ops_err_unused_tags:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg bar, !kwarg spam]]
          tag: foobarspam
        - define: 42
          tag: fourtytwo
        - pass: !dag_tag foobarspam

  _raises: MetaOperationError
  _match: "defines internal tags that are not used within the meta-operation: fourtytwo! Either remove these tags"


meta_ops_err_duplicate_internal_tags:
  params:
    meta_operations:
      weird_define:
        - define: [[!kwarg foo, !kwarg bar, !kwarg spam]]
          tag: foobar
        - define: 42
          tag: foobar
        - pass: !dag_tag foobar

  _raises: MetaOperationError
  _match: duplicate internal tag definitions .*foobar, foobar


# Allowing failure and using fallback -----------------------------------------

allow_failure_no_fallback:
  params:
    transform:
      - mul: [2, 3]
      - div: [!dag_prev , 0]
        tag: bad_div

  compute_only: [bad_div]
  _raises: DataOperationError
  _raises_on_compute: true
  _match: ZeroDivisionError

allow_failure:
  params:
    transform:
      - mul: [2, 3]
      - div: [!dag_prev , 0]
        allow_failure: silent
        fallback: some fallback string
        tag: division

  expected:
    results:
      division:
        compare_to: some fallback string

allow_failure_upstream:
  params:
    transform:
      - define: 42
      - define: !dag_prev
        tag: fallback_tag
      - mul: [2, 3]
      - div: [!dag_prev , 0]  # error is here
      - add: [!dag_prev , 1]
      - sub: [!dag_prev , 1]
        allow_failure: silent
        fallback: [foo, bar, {val: !dag_tag fallback_tag}]  # nested!
        tag: final_result

  expected:
    results:
      final_result:
        compare_to: [foo, bar, {val: 42}]

allow_failure_upstream_with_error_in_fallback:
  params:
    transform:
      - define: -42
      - import_and_call: [math, log10, !dag_prev ]  # error in fallback
      - add: [!dag_prev , 1]
      - define: !dag_prev
        tag: fallback_tag

      - mul: [2, 3]
      - div: [!dag_prev , 0]  # error
      - add: [!dag_prev , 1]
      - sub: [!dag_prev , 1]
        allow_failure: silent
        fallback: [foo, bar, {val: !dag_tag fallback_tag}]
        tag: final_result

  compute_only: [final_result]
  _raises: DataOperationError
  _raises_on_compute: true
  _match: "ValueError: math domain error"


# Examples in documentation ---------------------------------------------------
# Partly literal-included

doc_examples_with_previous_result:
  params:
    transform:
      - operation: mul
        args: [1, 2]
      - operation: mul
        args: [3]
        with_previous_result: true
      - operation: mul
        args: [4]
        with_previous_result: true
      - operation: mul
        args: [5]
        with_previous_result: true
        tag: f5


doc_examples_dag_prev:
  params:
    transform:
      - operation: define
        args: [10]
      - operation: sub
        args: [0, !dag_prev ]
      - operation: div
        args: [1, !dag_prev ]
      - operation: pow
        args: [10, !dag_prev ]
        tag: my_result


doc_examples_select:
  params:
    select:
      some_data: path/to/some_data
      more_data:
        path: path/to/more_data
    transform: ~

  expected:
    tags: [dag, dm, select_base, some_data, more_data]


doc_examples_select_with_transform:
  params:
    select:
      square_increment:
        path: path/to/some_data
        with_previous_result: true
        transform:
          - operation: squared
          - operation: increment
      some_sum:
        path: path/to/more_data
        transform:
          - operation: getattr
            args: [!dag_prev , data]
          - operation: sub
            args: [0, !dag_prev ]
          - operation: .sum
            args: [!dag_prev ]
    transform:
      - operation: add
        args: [!dag_tag square_increment, !dag_tag some_sum ]
        tag: my_result


doc_examples_minimal:
  params:
    ### Start -- dag_minimal_syntax
    select:
      some_data: path/to/some_data
      more_data: path/to/more_data
    transform:
      - add: [!dag_tag some_data, !dag_tag more_data]
      - increment
      - print
      - pow: [!dag_prev , 4]
        tag: my_result
    ### End ---- dag_minimal_syntax

  expected:
    tags: [dag, dm, select_base, some_data, more_data, my_result]


doc_examples_define:
  params:
    ### Start -- dag_define
    define:
      exponent: 4               # directly define some object
      days_to_seconds_factor:   # use a sequence of TransformationsDAG
        - expression: "60 * 60 * 24"
        - float
    select:
      some_data: path/to/some_data
      more_data: path/to/more_data
    transform:
      - add: [!dag_tag some_data, !dag_tag more_data]
      - mul: [!dag_prev , !dag_tag days_to_seconds_factor]
      - print
      - pow: [!dag_prev , !dag_tag exponent]
        tag: my_result
    ### End ---- dag_define

  expected:
    tags: [dag, dm, select_base, some_data, more_data, my_result,
           exponent, days_to_seconds_factor]


doc_examples_import_and_call:
  params:
    transform:
      - operation: import_and_call
        args: [numpy.random, randint]
        kwargs:
          low: 0
          high: 10
          size: [2, 3, 4]
        tag: random_integers

  expected:
    tags: [dag, dm, select_base, random_integers]


doc_examples_op_hooks_expression_minimal:
  params:
    ### Start -- dag_op_hooks_expression_minimal
    select:
      some_data: path/to/some_data
      more_data: path/to/more_data
    transform:
      - expression: (some_data + more_data + 1) ** 4
        tag: my_result
    ### End ---- dag_op_hooks_expression_minimal

  expected:
    tags: [dag, dm, select_base, some_data, more_data, my_result]
    results:
      my_result:
        type: ndarray


doc_examples_op_hooks_expression_expanded_minimal:
  params:
    ### Start -- dag_op_hooks_expression_expanded_minimal
    select:
      some_data: path/to/some_data
      more_data: path/to/more_data
    transform:
      - expression: (some_data + more_data + 1) ** 4
        kwargs:
          symbols:
            some_data: !dag_tag some_data
            more_data: !dag_tag more_data
        tag: my_result
    ### End ---- dag_op_hooks_expression_expanded_minimal

  expected:
    tags: [dag, dm, select_base, some_data, more_data, my_result]
    results:
      my_result:
        type: ndarray


doc_examples_op_hooks_expression_basics:
  params:
    ### Start -- dag_op_hooks_expression_basics
    transform:
      - define: 2
        tag: a
      - define: 3
        tag: b
      - define: 1.5
        tag: c
      - expression: a**b / (c - 1.)
        tag: result
    ### End ---- dag_op_hooks_expression_basics

  expected:
    tags: [dag, dm, select_base, a, b, c, result]
    results:
      result:
        type: float64
        compare_to: 16.


doc_examples_op_hooks_expression_prev:
  params:
    ### Start -- dag_op_hooks_expression_prev
    transform:
      - define: 3
        tag: x
      - define: 2.                       # ... or something more complicated
      - expression: 1 - prev/(1 + x)     # Reusing ``prev`` here. :tada:
        tag: result
    ### End ---- dag_op_hooks_expression_prev

  expected:
    tags: [dag, dm, select_base, x, result]
    results:
      result:
        type: float64
        compare_to: .5


doc_examples_op_hooks_expression_symbolic:
  params:
    ### Start -- dag_op_hooks_expression_symbolic
    transform:
      - np.array: [[1, 2, 3]]
        tag: arr
      - .mean: !dag_tag arr
        tag: a
      - .sum: !dag_tag arr
        tag: b
      - define: 10
        tag: c

      - operation: expression
        args: [a**2]
        kwargs:
          astype: ~
        tag: equation_one
      - operation: expression
        args: [b**2]
        kwargs:
          astype: ~
        tag: equation_two

      - expression: (equation_one + equation_two) * c**2
        tag: result
    ### End ---- dag_op_hooks_expression_symbolic

  expected:
    tags: [dag, dm, select_base, arr, a, b, c, equation_one, equation_two, result]
    results:
      result:
        type: float64
        compare_to: 4000.


doc_examples_dag_curve_fitting:
  params:
    ### Start -- dag_examples_curve_fitting
    select:
      data_to_fit: path/to/elephant_ts  # 1D data with `time` dimension

    transform:
      # Define the model function as a lambda
      - lambda: "lambda x, a0, a1, a2, a3, a4, a5: a5*x**5 + a4*x**4 + a3*x**3 + a2*x**2 + a1*x**1 + a0"
        tag: elephant_f

      # Extract the independent variable (here: the `time` coordinates)
      - .coords: [!dag_tag data_to_fit, time]
        tag: times

      # Do the fit; result will be that of `scipy.optimize.curve_fit`
      - curve_fit:
          - !dag_tag elephant_f
          - !dag_tag times
          - !dag_tag data_to_fit
        tag: fit_results
    ### End ---- dag_examples_curve_fitting

  expected:
    tags: [dag, dm, select_base, data_to_fit, elephant_f, times, fit_results]
    results:
      elephant_f:
        type: function
      fit_results:
        type: tuple


doc_examples_meta_ops_simple:
  params:
    ### Start -- dag_meta_ops_simple_def
    # Define meta-operations
    meta_operations:
      # Compute (x**2 + 1) for a positional input argument x
      square_plus_one:
        - pow: [!arg 0, 2]
        - add: [!dag_prev , 1]   # <-- this operation's result is the "return value"

      # Select some data and directly compute its mean
      select_and_compute_mean:
        select:
          data:
            path: !kwarg to_select
        transform:
          - .mean: !dag_tag data

    ### End ---- dag_meta_ops_simple_def
    ### Start -- dag_meta_ops_simple_use
    # Use the meta-operations within the regular data transformation, alongside
    # the already-existing data operations
    transform:
      - select_and_compute_mean:
          to_select: path/to/some_data
        tag: some_data_mean
      - select_and_compute_mean:
          to_select: path/to/more_data
        tag: more_data_mean
      - add: [!dag_tag some_data_mean, !dag_tag more_data_mean]
      - square_plus_one: !dag_prev
        tag: result
    ### End ---- dag_meta_ops_simple_use

  expected:
    tags: [dag, dm, select_base, some_data_mean, more_data_mean, result]
    results:
      result:
        type: float64


doc_examples_meta_ops_arg_def:
  params:
    ### Start -- dag_meta_ops_arg_def
    meta_operations:
      my_equation:  # [(a + b) * c - d] / e
        - add: [!kwarg a, !kwarg b]
        - mul: [!dag_prev , !kwarg c]
        - sub: [!dag_prev , !kwarg d]
        - div: [!dag_prev , !kwarg e]

    transform:
      - my_equation:
          a: 1
          b: 10
          c: 8
          d: 4
          e: 2
        tag: the_answer
    ### End ---- dag_meta_ops_arg_def

  expected:
    tags: [dag, dm, select_base, the_answer]
    results:
      the_answer:
        type: float
        compare_to: 42


doc_examples_meta_ops_definition_formats:
  params:
    ### Start -- dag_meta_ops_definition_formats
    meta_operations:
      # A -- as list  ==> transformations only
      a_plus_b_cubed:
        - add: [!arg 0, !arg 1]
        - pow: [!dag_prev , 3]

      # B -- as dict  ==>  selections _and_ transformations
      select_and_square:
        select:
          data:
            path: !kwarg to_select
        transform:
          - squared: !dag_tag data

    transform:
      - a_plus_b_cubed: [1, 2]
        tag: result1
      - select_and_square:
          to_select: path/to/some_data
        tag: result2
    ### End ---- dag_meta_ops_definition_formats

  expected:
    tags: [dag, dm, select_base, result1, result2]
    results:
      result1:
        type: int
        compare_to: 27
      result2:
        type: ndarray


doc_examples_meta_ops_tagging:
  params:
    ### Start -- dag_meta_ops_tagging
    meta_operations:
      my_meta_operation:  # [(x+1) * (x-1)] / (2*y)
        - add: [!arg 0, +1]
          tag: left
        - add: [!arg 0, -1]
          tag: right
        - mul: [!dag_tag left, !dag_tag right]
          tag: top
        - mul: [!arg 1, 2]
        - div: [!dag_tag top , !dag_prev ]

    transform:
      - my_meta_operation: [9, 2]  # [(9+1) * (9-1)] / (2*2) == 20
        tag: result
    ### End ---- dag_meta_ops_tagging
      - my_meta_operation: [0, .5]
        tag: result2

  expected:
    tags: [dag, dm, select_base, result, result2]
    results:
      result:
        type: float
        compare_to: 20
      result2:
        type: float
        compare_to: -1


doc_examples_meta_ops_args_with_defaults:
  params:
    ### Start -- dag_meta_ops_args_with_defaults
    meta_operations:
      my_increment:
        - add: [!arg 0, !arg [1, 1]]

    transform:
      - my_increment: [0]
        tag: one
      - my_increment: !dag_prev
        tag: two
      - my_increment: [!dag_prev , 8]
        tag: ten
    ### End ---- dag_meta_ops_args_with_defaults

  expected:
    tags: [dag, dm, select_base, one, two, ten]
    results:
      one:
        compare_to: 1
      two:
        compare_to: 2
      ten:
        compare_to: 10


doc_examples_meta_ops_prime_multiples:
  skip_on_windows: True # Fails because
  params:
    ### Start -- dag_meta_ops_prime_multiples
    meta_operations:
      prime_multiples:
        # Define powers of primes 2, 3, 5, and 7
        - pow: [2, !kwarg [base2, 0]]
          tag: b2
        - pow: [3, !kwarg [base3, 0]]
          tag: b3
        - pow: [5, !kwarg [base5, 0]]
          tag: b5
        - pow: [7, !kwarg [base7, 0]]
          tag: b7
        # Compute their product
        - np.: [prod, [!dag_tag b2, !dag_tag b3, !dag_tag b5, !dag_tag b7]]

    transform:
      - prime_multiples:
          base2: 2
          base3: 1
          # base5: 0
          base7: 3
        tag: result
    ### End ---- dag_meta_ops_prime_multiples

  expected:
    tags: [dag, dm, select_base, result]
    results:
      result:
        type: int64
        compare_to: 4116


doc_examples_meta_ops_multiple_return_values:
  params:
    ### Start -- dag_meta_ops_multiple_return_values
    meta_operations:
      # Given some input data (as positional argument), compute a bunch of
      # statistical quantities. To return them, aggregate them into a dict.
      compute_stats:
        # Make sure it's an xarray object
        - xr.DataArray: !arg 0
          tag: data

        # Compute the statistics
        - .mean: !dag_tag data
          tag: mean
        - .std: !dag_tag data
          tag: std
        - .median: !dag_tag data
          tag: median
        - .min: !dag_tag data
          tag: min
        - .max: !dag_tag data
          tag: max
        - .quantile: [!dag_tag data, 0.25]
          tag: q25
        - .quantile: [!dag_tag data, 0.75]
          tag: q75

        # Aggregate into a dict as return value
        - dict:
            mean: !dag_tag mean
            std: !dag_tag std
            median: !dag_tag median
            min: !dag_tag min
            max: !dag_tag max
            q25: !dag_tag q25
            q75: !dag_tag q75

    # Usage example: select some data and get some of the desired statistics
    select:
      some_data: path/to/some_data
    transform:
      - compute_stats: !dag_tag some_data
        tag: some_stats

      - getitem: [!dag_tag some_stats, mean]
        tag: some_mean
      - getitem: [!dag_tag some_stats, std]
        tag: some_std
      - getitem: [!dag_tag some_stats, median]
        tag: some_median
    ### End ---- dag_meta_ops_multiple_return_values
      - list: !dag_tag some_stats
        tag: available_keys

  expected:
    tags: [dag, dm, select_base, available_keys,
           some_data, some_mean, some_std, some_median, some_stats]
    results:
      some_mean:
        type: DataArray
      some_std:
        type: DataArray
      some_median:
        type: DataArray
      available_keys:
        type: list
        compare_to: [max, mean, median, min, q25, q75, std]


doc_examples_meta_ops_gauss_simple:
  params:
    ### Start -- dag_meta_ops_gauss_simple
    meta_operations:
      # A meta-operation that defines a gaussian
      my_gauss:
        - expression: a * exp(- (x - mu)**2 / (2 * sigma**2))
          kwargs:
            symbols:
              x: !kwarg x
              a: !kwarg a
              mu: !kwarg mu
              sigma: !kwarg sigma

    transform:
      # Compute the Gaussian for two values
      - my_gauss:
          a: 1.
          mu: 0.
          sigma: 1.
          x: 0.
        tag: default_gaussian
      - my_gauss:
          a: 1.
          mu: 23.
          sigma: 10.
          x: 23.
        tag: wide_gaussian_moved
    ### End ---- dag_meta_ops_gauss_simple
      # Some more for testing
      - my_gauss: &default_args
          a: 1.
          mu: 0.
          sigma: 1.
          x: 0.
        tag: gauss_at_zero
      - my_gauss:
          <<: *default_args
          a: 42
        tag: large_gauss
      - my_gauss:
          <<: *default_args
          mu: 42.
          x: 42.
        tag: moved_gauss
      - my_gauss:
          <<: *default_args
          a: 123.
          x: 100000.
        tag: zero_gauss

  expected: &gauss_expected
    tags: [dag, dm, select_base, default_gaussian, wide_gaussian_moved,
           gauss_at_zero, large_gauss, moved_gauss, zero_gauss]
    results:
      default_gaussian:
        compare_to: 1.
      wide_gaussian_moved:
        compare_to: 1.
      gauss_at_zero:
        compare_to: 1.
      large_gauss:
        compare_to: 42.
      moved_gauss:
        compare_to: 1.
      zero_gauss:
        compare_to: 0.


doc_examples_meta_ops_gauss_with_defaults:
  params:
    ### Start -- dag_meta_ops_gauss_with_defaults
    meta_operations:
      # A meta-operation that defines a gaussian
      my_gauss:
        - expression: a * exp(- (x - mu)**2 / (2 * sigma**2))
          kwargs:
            symbols:
              x: !kwarg x
              a: !kwarg [a, 1.]
              mu: !kwarg [mu, 0.]
              sigma: !kwarg [sigma, 1.]

    transform:
      # Compute the Gaussian for two values
      - my_gauss:
          x: 0.
        tag: default_gaussian
      - my_gauss:
          x: 23.
          a: 1.
          mu: 23.
          sigma: 10.
        tag: wide_gaussian_moved
    ### End ---- dag_meta_ops_gauss_with_defaults
      # Some more for testing
      - my_gauss:
          x: 0.
        tag: gauss_at_zero
      - my_gauss:
          x: 0
          a: 42
        tag: large_gauss
      - my_gauss:
          mu: 42.
          x: 42.
        tag: moved_gauss
      - my_gauss:
          a: 123.
          x: 100000.
        tag: zero_gauss

  expected:
    <<: *gauss_expected


doc_examples_meta_ops_anchor_usage:
  params:
    meta_operations:
      # A meta-operation that defines a gaussian
      my_gauss:
        - expression: a * exp(- (x - mu)**2 / (2 * sigma**2))
          kwargs:
            symbols:
              a: !kwarg a
              mu: !kwarg mu
              sigma: !kwarg sigma
              x: !kwarg x

    ### Start -- dag_meta_ops_anchor_usage
    transform:
      - my_gauss: &my_gauss_defaults    # <-- defines the defaults
          a: 1.
          mu: 0.
          sigma: 1.
          x: 0.
        tag: default_gaussian
      - my_gauss:
          <<: *my_gauss_defaults        # <-- re-use defaults ...
          a: 10.                        #     ... and update with new values
        tag: scaled_gaussian
      - my_gauss:
          <<: *my_gauss_defaults
          mu: -42.
        tag: moved_gaussian
    ### End ---- dag_meta_ops_anchor_usage

  expected:
    tags: [dag, dm, select_base,
           default_gaussian, scaled_gaussian, moved_gaussian]
    results:
      default_gaussian:
        compare_to: 1.


doc_examples_error_handling_first_examples:
  params:
    transform:
    ### Start -- dag_error_handling_example01
      - float: "inf"
      - div: [1, 0]               # 1 / 0  -->  raises ZeroDivisionError
        allow_failure: true
        fallback: !dag_prev
        tag: result
    ### End ---- dag_error_handling_example01

    ### Start -- dag_error_handling_example02
      - float: "inf"
      - div: [1, 0]
        allow_failure: silent     # can also be: True, log, warn, False
        fallback: !dag_prev
    ### End ---- dag_error_handling_example02
        tag: result_silent

    ### Start -- dag_error_handling_example03
      # Example input: assume that this may also be the output from previous
      # operations which are used to calculate something else ...
      - define: -1.23
        tag: some_value
      - define: +1
        tag: some_other_value

      # Perform some potentially problematic operations with these ...
      - import_and_call: [math, log10, !dag_tag some_value]   # --> ValueError
        tag: log10_value

      - import: [np, pi]
        tag: pi
      - sub: [!dag_tag some_other_value, 1.]
      - div: [!dag_tag pi, !dag_prev ]                        # --> ZeroDivisionError
        tag: pi_over_some_other_value

      # ... leading to the result
      - add: [!dag_tag log10_value, !dag_tag pi_over_some_other_value]
        allow_failure: true
        fallback: 42
        tag: my_result
    ### End ---- dag_error_handling_example03

  compute_only: [result, result_silent, my_result]
  expected:
    tags: [dag, dm, select_base,
           result, result_silent,
           some_value, some_other_value, log10_value, pi,
           pi_over_some_other_value, my_result]
    results:
      my_result:
        compare_to: 42


doc_examples_error_handling_select:
  params:
    ### Start -- dag_error_handling_select_simple_fallback
    select:
      some_data: path/to/some_data
      mean_data:
        path: some/invalid/path       # The underlying `getitem` will fail ...
        allow_failure: true           # ... but is allowed to.
        fallback: [[1, 2, 3]]         # Instead, this fallback value is used.
        transform:
          - np.mean                   # ... which still works for a mean

    transform:
      - expression: (some_data + mean_data + 1) ** 4
        tag: my_result
    ### End ---- dag_error_handling_select_simple_fallback

  expected:
    tags: [dag, dm, select_base, some_data, mean_data, my_result]
    results:
      my_result:
        type: ndarray


doc_examples_error_handling_select_tagged_fallback:
  params:
    ### Start -- dag_error_handling_select_tagged_fallback
    select:
      _some_fallback_data: path/to/some_data
      mean_data:
        path: some/invalid/path
        allow_failure: true
        fallback: !dag_tag _some_fallback_data
        transform:
          - np.mean

    transform:
      - expression: (mean_data + 1) ** (-0.5)
        tag: my_result
    ### End ---- dag_error_handling_select_tagged_fallback

  expected:
    tags: [dag, dm, select_base, _some_fallback_data, mean_data, my_result]
    results:
      my_result:
        type: float64


doc_examples_err_and_fallback:
  params:
    ### Start -- dag_err_and_fallback
    select:
      some_data: path/to/some_data
      more_data: path/to/more_data
    transform:
      - add: [!dag_tag some_data, !dag_tag more_data]
      - pow: [!dag_prev , 4, some_bad_argument]
        allow_failure: true
        fallback: !dag_prev
      - increment: !dag_prev
      - sub: [!dag_prev , foo]  # bad argument
      - increment: !dag_prev
        tag: my_result
    ### End ---- dag_err_and_fallback
  _raises_on_compute: true
  _raises: DataOperationError
  expected:
    tags: [dag, dm, select_base, some_data, more_data, my_result]


doc_examples_gen_nx_custom_description:
  params:
    ### Start -- dag_gen_nx_custom_description
    define:
      exponent: 4               # directly define some object
      days_to_seconds_factor:   # use a sequence of TransformationsDAG
        - expression: "60 * 60 * 24"
        - float
    select:
      some_data: path/to/some_data
      more_data: path/to/more_data
    transform:
      - add: [!dag_tag some_data, !dag_tag more_data]
      - mul: [!dag_prev , !dag_tag days_to_seconds_factor]
      - print
      - pow: [!dag_prev , !dag_tag exponent]
        tag: my_result
    ### End ---- dag_gen_nx_custom_description

  expected:
    tags: [dag, dm, select_base, some_data, more_data, my_result, exponent, days_to_seconds_factor]
    results:
      my_result:
        type: NumpyDataContainer
